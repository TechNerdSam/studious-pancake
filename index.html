<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <!-- Viewport sécurisé pour éviter le zoom tactile accidentel -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, viewport-fit=cover">
    <title>NÉON CINÉTIQUE // ULTIMATE 2026</title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 fill=%22%23020204%22/><circle cx=%2232%22 cy=%2232%22 r=%2212%22 fill=%22%2300f3ff%22/><path d=%22M32 10v44M10 32h44%22 stroke=%22%23ff0055%22 stroke-width=%224%22/></svg>">

    <style>
        /* --- CORE VISUALS --- */
        :root {
            --c-void: #050505;
            --c-cyan: #00f3ff;
            --c-magenta: #ff0055;
            --c-gold: #ffcc00;
            --c-acid: #ccff00;
            --font-main: 'Rajdhani', sans-serif;
            --ease-out-expo: cubic-bezier(0.19, 1, 0.22, 1);
        }

        body {
            margin: 0; background: var(--c-void); overflow: hidden;
            font-family: var(--font-main); color: white;
            user-select: none; -webkit-user-select: none;
            /* CRUCIAL POUR MOBILE : Empêche le scroll quand on joue */
            touch-action: none; 
            cursor: none;
        }

        canvas { display: block; width: 100vw; height: 100vh; position: fixed; z-index: 0; outline: none; }

        /* --- UI LAYER (HUD) --- */
        #ui-layer {
            position: absolute; inset: 0; pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between; padding: 3vmin;
            transition: opacity 0.5s;
        }

        .hud-hidden { opacity: 0 !important; }

        .hud-top {
            display: flex; justify-content: space-between; font-size: 2vmin; font-weight: 700;
            letter-spacing: 0.2em; text-transform: uppercase; color: rgba(255,255,255,0.5);
            text-shadow: 0 2px 10px rgba(0,0,0,0.8);
        }

        .score-board {
            position: absolute; top: 12%; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15vw; font-size: 12vmin; font-weight: 900; line-height: 0.8;
            opacity: 0.15; z-index: -1; transition: all 0.3s;
        }
        .score-board.active { opacity: 0.25; gap: 20vw; }
        .score-board.match-point { opacity: 0.5; text-shadow: 0 0 50px var(--c-magenta); }

        #p1-score { color: var(--c-cyan); }
        #p2-score { color: var(--c-magenta); }

        .message-center {
            position: absolute; top: 40%; width: 100%; text-align: center;
            font-size: 6vmin; font-weight: 900; font-style: italic; letter-spacing: 0.1em;
            text-transform: uppercase; opacity: 0; transform: scale(0.9) skewX(-20deg);
            transition: all 0.4s var(--ease-out-expo); filter: blur(10px);
            pointer-events: none;
        }
        .message-active { opacity: 1; transform: scale(1) skewX(0deg); filter: blur(0px); text-shadow: 0 10px 40px rgba(0,0,0,0.8); }

        /* --- MAIN MENU (AAA DESIGN 2026) --- */
        #main-menu {
            position: absolute; inset: 0; z-index: 20;
            display: flex; flex-direction: column; justify-content: center; align-items: flex-start;
            padding-left: 8vw;
            background: linear-gradient(90deg, rgba(0,0,0,0.95) 0%, rgba(0,0,0,0.8) 40%, rgba(0,0,0,0.4) 100%);
            transition: opacity 0.8s var(--ease-out-expo), transform 0.8s var(--ease-out-expo);
            backdrop-filter: blur(5px);
        }

        /* Mobile adaptation for menu */
        @media (max-width: 768px) {
            #main-menu { align-items: center; padding-left: 0; text-align: center; background: rgba(0,0,0,0.85); }
            .menu-options { align-items: center; border-left: none; padding-left: 0; }
            .menu-btn { justify-content: center; }
            .menu-footer { left: 50%; transform: translateX(-50%); text-align: center; bottom: 4vmin; }
            .hero-title { font-size: 15vmin; }
        }

        .menu-hidden { opacity: 0 !important; pointer-events: none; transform: scale(1.05); }

        .hero-title {
            font-size: 12vmin; line-height: 0.85; font-weight: 800; text-transform: uppercase;
            letter-spacing: -0.03em; color: white; margin-bottom: 6vmin;
            position: relative;
            text-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .hero-title .sub {
            display: block; font-size: 2vmin; letter-spacing: 0.8em; 
            color: var(--c-cyan); font-weight: 600; margin-bottom: 1vmin; margin-left: 0.5vmin;
        }
        
        .hero-title .highlight {
            color: transparent; -webkit-text-stroke: 2px white; 
            position: relative; display: inline-block;
        }
        .hero-title .highlight::after {
            content: attr(data-content); position: absolute; left: 0; top: 0;
            color: white; opacity: 0; animation: glitch-anim 4s infinite;
            -webkit-text-stroke: 0;
        }

        .menu-options { 
            display: flex; flex-direction: column; gap: 2vmin; 
            position: relative; padding-left: 2vmin;
            border-left: 2px solid rgba(255,255,255,0.1);
        }

        .menu-btn {
            background: transparent; border: none; color: rgba(255,255,255,0.5);
            font-family: var(--font-main); font-size: 4vmin; font-weight: 700; text-transform: uppercase;
            cursor: pointer; text-align: left; padding: 1.5vmin 2vmin;
            transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94); 
            position: relative; letter-spacing: 0.1em;
            display: flex; align-items: center; width: 100%;
        }

        .menu-btn:hover, .menu-btn:active { 
            color: white; padding-left: 3vmin; 
            text-shadow: 0 0 20px var(--c-cyan);
        }
        
        .menu-btn .icon {
            font-size: 0.6em; margin-right: 1.5vmin; opacity: 0; transform: translateX(-10px);
            transition: all 0.2s; color: var(--c-magenta);
        }
        .menu-btn:hover .icon, .menu-btn:active .icon { opacity: 1; transform: translateX(0); }

        .menu-footer {
            position: absolute; bottom: 6vmin; left: 8vw;
            font-size: 1.5vmin; color: rgba(255,255,255,0.3); 
            font-family: monospace; letter-spacing: 0.1em;
            border-top: 1px solid rgba(255,255,255,0.1); padding-top: 2vmin; min-width: 250px;
        }
        
        .menu-status {
            position: absolute; top: 6vmin; right: 6vmin;
            display: flex; gap: 2vmin; align-items: center;
            font-size: 1.5vmin; color: rgba(255,255,255,0.6); letter-spacing: 0.2em;
        }
        .status-dot { width: 8px; height: 8px; background: var(--c-acid); border-radius: 50%; box-shadow: 0 0 10px var(--c-acid); }

        /* --- POST FX OVERLAYS --- */
        .scanlines {
            position: absolute; inset: 0; pointer-events: none; z-index: 100;
            background: linear-gradient(to bottom, rgba(0,0,0,0) 50%, rgba(0,0,0,0.1) 50%);
            background-size: 100% 4px; opacity: 0.3;
        }
        .vignette {
            position: absolute; inset: 0; pointer-events: none; z-index: 90;
            background: radial-gradient(circle, transparent 50%, black 120%);
        }
        
        .loading-overlay {
            position: absolute; inset: 0; background: #000; z-index: 200;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            transition: opacity 0.8s;
        }
        .loader-track { width: 40vw; max-width: 300px; height: 2px; background: #222; overflow: visible; margin-top: 2rem; position: relative;}
        .loader-fill { 
            width: 0%; height: 100%; background: var(--c-cyan); 
            box-shadow: 0 0 30px var(--c-cyan), 0 0 10px white; 
            transition: width 0.1s; position: relative;
        }
        
        /* Modal Styles Game Over & Pause */
        .modal {
            position: absolute; inset: 0; background: rgba(0,0,0,0.92); z-index: 50; 
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            opacity: 1; transition: opacity 0.5s; pointer-events: auto; backdrop-filter: blur(10px);
        }
        .hidden { opacity: 0 !important; pointer-events: none !important; }

        @keyframes glitch-anim {
            0%, 100% { opacity: 0; transform: translate(0); clip-path: polygon(0 0, 100% 0, 100% 100%, 0 100%); }
            10% { opacity: 1; transform: translate(-2px, 1px); clip-path: polygon(0 10%, 100% 10%, 100% 20%, 0 20%); }
            15% { opacity: 1; transform: translate(2px, -1px); clip-path: polygon(0 80%, 100% 80%, 100% 90%, 0 90%); }
            20% { opacity: 0; }
        }

        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700;800;900&display=swap');
    </style>
    
    <!-- IMPORT MAP (Using explicit versions for stability) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <!-- VISUAL OVERLAYS -->
    <div class="scanlines"></div>
    <div class="vignette"></div>
    
    <!-- INITIAL LOADER -->
    <div id="loader" class="loading-overlay">
        <div style="font-size: 5vmin; font-weight:900; letter-spacing: -0.05em; color: white;">NC // 2026</div>
        <div class="loader-track"><div class="loader-fill" id="load-bar"></div></div>
        <div style="margin-top: 1rem; font-size: 1.5vmin; color: #555; letter-spacing: 0.2em;">SYSTEM INITIALIZATION</div>
    </div>

    <!-- MAIN MENU AAA -->
    <div id="main-menu" class="hidden">
        <div class="menu-status">
            <div class="status-dot"></div>
            ONLINE
        </div>

        <div class="hero-title">
            <span class="sub">DIRECTOR'S CUT</span>
            NÉON<br>
            <span class="highlight" data-content="CINÉTIQUE">CINÉTIQUE</span>
        </div>
        
        <div class="menu-options">
            <button class="menu-btn" id="btn-play">
                <span class="icon">▶</span> MATCH RAPIDE
            </button>
            <button class="menu-btn" id="btn-survival">
                <span class="icon">⚡</span> MODE SURVIE
            </button>
            <button class="menu-btn" id="btn-fullscreen">
                <span class="icon">⛶</span> PLEIN ÉCRAN
            </button>
        </div>
        
        <div class="menu-footer">
            V 2026.9.4 [RESPONSIVE CORE]<br>
            SAMYN-ANTOY // STUDIO 55<br>
            <span style="color:var(--c-cyan)">TAP OR CLICK TO START</span>
        </div>
    </div>

    <!-- IN-GAME HUD -->
    <div id="ui-layer" class="hud-hidden">
        <div class="hud-top">
            <div><span id="score-limit" style="color:var(--c-gold)">5 PTS</span> VICTOIRE</div>
            <div id="match-status">LIVE</div>
        </div>
        
        <div class="score-board" id="sb-container">
            <div id="p1-score">0</div>
            <div id="p2-score">0</div>
        </div>

        <div id="msg-box" class="message-center"></div>

        <div style="position: absolute; bottom: 3vmin; width: 100%; text-align: center; opacity: 0.6; font-size: 1.5vmin; letter-spacing: 2px;">
            CONTROLS: MOUSE / TOUCH - [ESC]: PAUSE
        </div>
    </div>

    <!-- PAUSE MENU -->
    <div id="pause-menu" class="modal hidden">
        <h1 style="font-size: 8vmin; margin:0; text-transform:uppercase; color:white; letter-spacing: 0.2em; text-shadow: 0 0 30px var(--c-cyan);">PAUSE</h1>
        <div style="width: 100px; height: 2px; background: var(--c-magenta); margin: 2rem 0;"></div>
        <div style="display:flex; gap: 2rem; flex-direction: column; width: 100%; max-width: 300px;">
            <button id="btn-resume" class="menu-btn" style="color: var(--c-cyan); border-left:none; padding-left:0; justify-content: center; text-align: center;">REPRENDRE</button>
            <button id="btn-quit" class="menu-btn" style="color: var(--c-magenta); border-left:none; padding-left:0; justify-content: center; text-align: center;">QUITTER</button>
        </div>
    </div>

    <!-- GAME OVER OVERLAY -->
    <div id="menu-over" class="modal hidden">
        <h1 id="win-title" style="font-size: 8vmin; margin:0; text-transform:uppercase; color:white;">GAME OVER</h1>
        <div style="font-size: 3vmin; margin-bottom: 2rem; letter-spacing: 0.2em; color: #888;">SCORE: <span id="final-score" style="color:white">0</span></div>
        <div style="display:flex; gap: 2rem; flex-wrap: wrap; justify-content: center;">
            <button id="btn-retry" class="menu-btn" style="color: var(--c-cyan); border-left:none; padding-left:0; width: auto;">REJOUER</button>
            <button id="btn-menu" class="menu-btn" style="border-left:none; padding-left:0; width: auto;">MENU</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
        import { FXAAShader } from 'three/addons/shaders/FXAAShader.js';

        // --- CONSTANTS & CONFIGURATION ---
        const CFG = {
            FIELD: { W: 50, H: 30 },
            GAME: { WIN_SCORE: 5, MATCH_POINT: 4 },
            COLORS: { 
                P1: 0x00f3ff, P2: 0xff0055, BALL: 0xffffff, 
                GRID: 0x111111, GOLD: 0xffcc00, ELECTRIC: 0xccff00, SHIELD: 0x00ff88 
            },
            PHYSICS: { BASE_SPEED: 32, MAX_SPEED: 95, SPIN_FORCE: 20 },
            CAM: { FOV: 40, MENU_Z: 35, PLAY_Z: 45 }
        };

        /**
         * INPUT MANAGER - Handles Mouse & Touch uniformly
         * Robustness: Normalizes coordinates to -1..1 range for gameplay consistency across devices
         */
        class InputManager {
            constructor() {
                this.y = 0; // Normalized -1 to 1
                this.isInteracting = false;
                this.handlers = [];

                // Bind events
                document.addEventListener('mousemove', this.onMove.bind(this));
                document.addEventListener('touchmove', this.onTouch.bind(this), { passive: false });
                document.addEventListener('touchstart', () => this.isInteracting = true);
                
                // Click/Tap generic handler
                const action = (e) => {
                    this.isInteracting = true;
                    this.handlers.forEach(h => h(e));
                };
                document.addEventListener('mousedown', action);
                document.addEventListener('touchstart', action);
            }

            onMove(e) {
                // Map clientY to -1 (top) to 1 (bottom) roughly
                // We use window.innerHeight to normalize
                this.y = -(e.clientY / window.innerHeight) * 2 + 1;
                this.isInteracting = true;
            }

            onTouch(e) {
                if(e.touches.length > 0) {
                    e.preventDefault(); // Prevent scroll
                    const t = e.touches[0];
                    this.y = -(t.clientY / window.innerHeight) * 2 + 1;
                    this.isInteracting = true;
                }
            }

            onClick(callback) {
                this.handlers.push(callback);
            }

            getNormalizedY() {
                // Returns value between -1 and 1
                return Math.max(-1, Math.min(1, this.y));
            }
        }

        /**
         * AUDIO CORE - AudioContext Safety Wrapper
         * Robustness: Handles auto-resume policies of modern browsers
         */
        class AudioCore {
            constructor() {
                this.ready = false;
                try {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AC();
                    this.master = this.ctx.createGain();
                    this.master.gain.value = 0.4;
                    
                    // Simple compression for punchy sound
                    this.comp = this.ctx.createDynamicsCompressor();
                    this.master.connect(this.comp);
                    this.comp.connect(this.ctx.destination);
                    
                    this.reverb = this.createImpulse(2.5);
                    this.revGain = this.ctx.createGain();
                    this.revGain.gain.value = 0.3;
                    this.comp.connect(this.revGain);
                    this.revGain.connect(this.reverb);
                    this.reverb.connect(this.ctx.destination);
                    this.ready = true;
                } catch (e) {
                    console.warn("Audio init failed:", e);
                }
            }

            async resume() {
                if(this.ready && this.ctx.state === 'suspended') {
                    await this.ctx.resume();
                }
            }

            createImpulse(sec) {
                if(!this.ready) return null;
                const len = this.ctx.sampleRate * sec;
                const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
                for(let i=0; i<len; i++) {
                    const d = Math.pow(1 - i/len, 2);
                    buf.getChannelData(0)[i] = (Math.random()*2-1)*d;
                    buf.getChannelData(1)[i] = (Math.random()*2-1)*d;
                }
                const c = this.ctx.createConvolver();
                c.buffer = buf;
                return c;
            }

            playUI(type) {
                if(!this.ready) return;
                const t = this.ctx.currentTime;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                
                if (type === 'hover') {
                    o.type = 'sine'; o.frequency.setValueAtTime(400, t);
                    g.gain.setValueAtTime(0.05, t); g.gain.linearRampToValueAtTime(0, t+0.05);
                } else if (type === 'click') {
                    o.type = 'triangle'; o.frequency.setValueAtTime(800, t); o.frequency.exponentialRampToValueAtTime(100, t+0.1);
                    g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.15);
                }
                
                o.connect(g); g.connect(this.master);
                o.start(); o.stop(t+0.2);
            }

            playImpact(intensity, type) {
                if(!this.ready) return;
                const t = this.ctx.currentTime;
                const o = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                
                if (type === 'wall') {
                    o.frequency.setValueAtTime(100, t); o.frequency.exponentialRampToValueAtTime(10, t+0.3);
                    g.gain.setValueAtTime(intensity, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.3);
                } else { // Paddle
                    o.type = 'square'; o.frequency.setValueAtTime(200, t); o.frequency.linearRampToValueAtTime(600, t+0.05);
                    g.gain.setValueAtTime(0.3*intensity, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
                }
                o.connect(g); g.connect(this.master); o.start(); o.stop(t+0.5);
            }
        }

        // --- VISUALS ---
        class Visuals {
            constructor(scene, cam, rend) {
                this.scene = scene; this.camera = cam;
                this.cmp = new EffectComposer(rend);
                
                // Add Pass safely
                const renderPass = new RenderPass(scene, cam);
                this.cmp.addPass(renderPass);
                
                // Bloom optimization: resolution matching renderer
                const res = new THREE.Vector2();
                rend.getSize(res);
                this.bloom = new UnrealBloomPass(res, 1.5, 0.4, 0.85);
                this.bloom.strength = 2.5; this.bloom.radius = 0.8; this.bloom.threshold = 0.1;
                this.cmp.addPass(this.bloom);

                this.uni = { tDiffuse: {value:null}, aberration: {value:0.005}, time: {value:0}, blur: {value:0} };
                
                const shader = {
                    uniforms: this.uni,
                    vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
                    fragmentShader: `
                        uniform sampler2D tDiffuse; uniform float aberration; uniform float time; uniform float blur; varying vec2 vUv;
                        float rand(vec2 co){ return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }
                        void main() {
                            vec2 uv = vUv;
                            // Chromatic Aberration
                            float r = texture2D(tDiffuse, uv + vec2(aberration, 0)).r;
                            float g = texture2D(tDiffuse, uv).g;
                            float b = texture2D(tDiffuse, uv - vec2(aberration, 0)).b;
                            
                            // Noise / Grain
                            float noise = rand(uv * time) * 0.05;
                            
                            // Blur simulation (cheap)
                            vec3 color = vec3(r,g,b);
                            if(blur > 0.0) { color = mix(color, vec3(0.05), blur * 0.5); } 

                            // Scanlines
                            float scan = sin(uv.y * 1000.0 + time * 5.0) * 0.02;
                            
                            gl_FragColor = vec4(color + noise + scan, 1.0);
                        }
                    `
                };
                this.cmp.addPass(new ShaderPass(shader));
                this.cmp.addPass(new ShaderPass(FXAAShader));
                
                this.shake = 0;
                
                // Particles - Efficient InstancedMesh
                this.parts = [];
                this.pMesh = new THREE.InstancedMesh(new THREE.PlaneGeometry(0.3,0.3), new THREE.MeshBasicMaterial({color:0xffffff}), 1000);
                // Optimization: Don't compute frustum for particles
                this.pMesh.frustumCulled = false; 
                scene.add(this.pMesh);
                this.dummy = new THREE.Object3D();
            }

            resize(w, h) {
                this.cmp.setSize(w, h);
                this.bloom.resolution.set(w, h);
            }

            emit(x, y, color, count) {
                for(let i=0; i<count; i++) {
                    const a = Math.random()*Math.PI*2; const s = Math.random()*15;
                    this.parts.push({x, y, vx:Math.cos(a)*s, vy:Math.sin(a)*s, life:1, color:new THREE.Color(color)});
                }
            }

            update(dt) {
                this.uni.time.value += dt;
                
                // Camera Shake Decay
                if(this.shake > 0) {
                    this.camera.position.x += (Math.random()-0.5)*this.shake;
                    this.camera.position.y += (Math.random()-0.5)*this.shake;
                    this.shake *= 0.9;
                    if(this.shake < 0.01) {
                         this.shake = 0;
                         this.camera.position.x = 0;
                         this.camera.position.y = 0;
                    }
                }
                
                // Particles update
                let idx = 0;
                for(let i=this.parts.length-1; i>=0; i--) {
                    let p = this.parts[i]; p.x += p.vx*dt; p.y += p.vy*dt; p.life *= 0.95;
                    if(p.life < 0.01) { this.parts.splice(i,1); continue; }
                    this.dummy.position.set(p.x, p.y, 0); this.dummy.scale.setScalar(p.life); this.dummy.updateMatrix();
                    this.pMesh.setMatrixAt(idx, this.dummy.matrix); this.pMesh.setColorAt(idx, p.color); idx++;
                }
                this.pMesh.count = idx; 
                if(idx > 0) {
                    this.pMesh.instanceMatrix.needsUpdate = true;
                    if(this.pMesh.instanceColor) this.pMesh.instanceColor.needsUpdate = true;
                }
            }
        }

        // --- GAME ENTITIES ---
        class Paddle {
            constructor(scene, x, color) {
                this.pos = new THREE.Vector2(x,0); this.color = color; this.h = 6;
                // Material Optimization: Reuse standard material isn't necessary here as there are only 2
                this.mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshStandardMaterial({color:0x222222, emissive:color, emissiveIntensity:2}));
                this.light = new THREE.PointLight(color, 80, 12);
                scene.add(this.mesh); scene.add(this.light);
                
                // Shield
                this.shield = new THREE.Mesh(new THREE.BoxGeometry(1,10,0.1), new THREE.MeshBasicMaterial({color:CFG.COLORS.SHIELD, transparent:true, opacity:0, wireframe:true}));
                this.shield.position.x = x > 0 ? 2 : -2;
                this.mesh.add(this.shield);
                this.shieldActive = false;
            }
            update(y, dt) {
                // Lerp for smooth movement
                this.pos.y += (y - this.pos.y) * 10 * dt;
                
                // Clamp within play area
                const lim = (CFG.FIELD.H - this.h)/2;
                this.pos.y = THREE.MathUtils.clamp(this.pos.y, -lim, lim);
                
                this.mesh.position.set(this.pos.x, this.pos.y, 0);
                this.mesh.scale.y = this.h;
                this.light.position.set(this.pos.x, this.pos.y, 2);
                
                if(this.shieldActive) {
                    this.shield.material.opacity = 0.3 + Math.sin(Date.now()*0.01)*0.1;
                    this.shield.rotation.y += dt;
                } else { this.shield.material.opacity = 0; }
            }
        }

        class Ball {
            constructor(scene) {
                this.pos = new THREE.Vector2(); this.vel = new THREE.Vector2(); this.active = false; this.radius = 0.6;
                this.mesh = new THREE.Mesh(new THREE.IcosahedronGeometry(0.6,1), new THREE.MeshStandardMaterial({color:0xffffff, emissive:0xffffff, emissiveIntensity:5}));
                scene.add(this.mesh);
                
                this.trail = new THREE.Mesh(new THREE.PlaneGeometry(1,1,1,20), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.5, side:THREE.DoubleSide}));
                scene.add(this.trail);
                this.pts = [];
            }
            spawn(x,y,vx,vy) { this.active=true; this.pos.set(x,y); this.vel.set(vx,vy); this.pts=[]; this.mesh.visible=true; this.trail.visible=true; }
            update(dt) {
                if(!this.active) return;
                this.pos.addScaledVector(this.vel, dt);
                this.mesh.position.set(this.pos.x, this.pos.y, 0);
                this.mesh.lookAt(this.pos.x+this.vel.x, this.pos.y+this.vel.y, 0);
                this.mesh.scale.set(1+this.vel.length()*0.01, 1/(1+this.vel.length()*0.01), 1);
                
                // Trail Logic
                this.pts.unshift(this.pos.clone()); if(this.pts.length>20) this.pts.pop();
                const arr = this.trail.geometry.attributes.position.array;
                for(let i=0; i<this.pts.length; i++) {
                    const w = (1-i/20)*0.6;
                    // Create a simple ribbon
                    arr[i*6] = this.pts[i].x; arr[i*6+1] = this.pts[i].y+w; arr[i*6+2]=0;
                    arr[i*6+3] = this.pts[i].x; arr[i*6+4] = this.pts[i].y-w; arr[i*6+5]=0;
                }
                this.trail.geometry.attributes.position.needsUpdate = true;
            }
        }

        class PowerUp {
            constructor(scene, type) {
                this.type = type; this.active = true;
                this.pos = new THREE.Vector2((Math.random()-0.5)*30, (Math.random()-0.5)*20);
                const col = type === 'SHIELD' ? CFG.COLORS.SHIELD : (type === 'MULTI' ? CFG.COLORS.P2 : CFG.COLORS.ELECTRIC);
                this.mesh = new THREE.Mesh(new THREE.OctahedronGeometry(1), new THREE.MeshStandardMaterial({color:0x111111, emissive:col, emissiveIntensity:3, wireframe:true}));
                this.mesh.position.set(this.pos.x, this.pos.y, 0);
                this.color = new THREE.Color(col);
                scene.add(this.mesh);
            }
            update(t) { this.mesh.rotation.y = t; this.mesh.rotation.z = t*0.5; this.mesh.position.y = this.pos.y + Math.sin(t*3)*0.5; }
            kill(s) { this.active=false; s.remove(this.mesh); if(this.mesh.geometry) this.mesh.geometry.dispose(); }
        }

        // --- GAME ENGINE CONTROLLER ---
        class Game {
            constructor() {
                this.state = 'LOAD'; // LOAD -> ATTRACT -> PLAY -> OVER -> PAUSED
                this.mode = 'STANDARD'; 
                this.score = {p1:0, p2:0};
                this.targetCamZ = CFG.CAM.MENU_Z;
                
                try {
                    this.initScene();
                    this.input = new InputManager();
                    this.audio = new AudioCore();
                    this.vfx = new Visuals(this.scene, this.camera, this.renderer);
                    
                    this.p1 = new Paddle(this.scene, -22, CFG.COLORS.P1);
                    this.p2 = new Paddle(this.scene, 22, CFG.COLORS.P2);
                    this.balls = [new Ball(this.scene), new Ball(this.scene), new Ball(this.scene)];
                    this.powerups = [];
                    
                    this.clock = new THREE.Clock();
                    
                    this.setupEvents();
                    this.startLoading();
                    this.handleResize(); // Initial fit
                    
                    this.animate = this.animate.bind(this);
                    requestAnimationFrame(this.animate);
                } catch(e) {
                    console.error("Critical Engine Failure", e);
                    alert("Votre appareil ne supporte pas WebGL 2.0");
                }
            }

            initScene() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(CFG.CAM.FOV, window.innerWidth/window.innerHeight, 0.1, 100);
                
                this.renderer = new THREE.WebGLRenderer({antialias:false, powerPreference:"high-performance"});
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Cap PixelRatio for performance
                document.body.appendChild(this.renderer.domElement);
                
                // Retro Grid
                const g = new THREE.GridHelper(100, 50, 0x444444, 0x050505);
                g.rotation.x = Math.PI/2; g.position.z = -5;
                this.scene.add(g);
            }

            setupEvents() {
                window.addEventListener('resize', () => this.handleResize());
                
                // Keyboard Listeners
                window.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') this.togglePause();
                });

                // UI Interaction
                this.input.onClick((e) => {
                   this.audio.playUI('click');
                   this.audio.resume(); // Ensure audio unlocks on mobile
                   if(this.state === 'ATTRACT') this.transitionToGame('STANDARD');
                });

                // Bind Buttons
                const bind = (id, fn) => {
                    const el = document.getElementById(id);
                    if(el) el.addEventListener('click', (e) => {
                        e.stopPropagation();
                        this.audio.resume();
                        fn();
                    });
                };

                bind('btn-play', () => this.transitionToGame('STANDARD'));
                bind('btn-survival', () => this.transitionToGame('SURVIVAL'));
                bind('btn-fullscreen', () => this.toggleFS());
                bind('btn-retry', () => this.transitionToGame(this.mode));
                bind('btn-menu', () => this.goToMenu());
                
                // Pause Menu Buttons
                bind('btn-resume', () => this.togglePause());
                bind('btn-quit', () => this.goToMenu());
            }

            handleResize() {
                const w = window.innerWidth;
                const h = window.innerHeight;
                this.camera.aspect = w / h;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(w, h);
                this.vfx.resize(w, h);

                // --- RESPONSIVE CAMERA LOGIC ---
                // Calculate required distance to fit the Field Width (50) and Height (30)
                // tan(fov/2) = (height/2) / distance
                const tan = Math.tan((Math.PI/180) * this.camera.fov/2);
                
                // Distance to fit height
                const distH = (CFG.FIELD.H/2 + 5) / tan; // +5 padding
                
                // Distance to fit width (depends on aspect ratio)
                // visibleWidth = visibleHeight * aspect
                // We need visibleWidth >= FIELD.W
                const distW = (CFG.FIELD.W/2 + 2) / (tan * this.camera.aspect);

                // Choose the furthest distance to ensure everything fits
                this.baseCamZ = Math.max(distH, distW);
                
                if(this.state === 'ATTRACT') this.targetCamZ = this.baseCamZ * 0.8;
                else this.targetCamZ = this.baseCamZ;
            }

            toggleFS() {
                if(!document.fullscreenElement) document.documentElement.requestFullscreen().catch(e=>{});
                else document.exitFullscreen().catch(e=>{});
            }
            
            togglePause() {
                // Can only pause if playing or already paused
                if (this.state !== 'PLAYING' && this.state !== 'PAUSED') return;

                if (this.state === 'PLAYING') {
                    this.state = 'PAUSED';
                    document.getElementById('pause-menu').classList.remove('hidden');
                    document.getElementById('ui-layer').classList.add('hud-hidden');
                    // Add blur for visual pause indication
                    this.vfx.uni.blur.value = 0.5;
                } else {
                    this.state = 'PLAYING';
                    document.getElementById('pause-menu').classList.add('hidden');
                    document.getElementById('ui-layer').classList.remove('hud-hidden');
                    this.vfx.uni.blur.value = 0;
                    // Reset clock delta so physics don't jump
                    this.clock.getDelta();
                }
            }

            startLoading() {
                let p = 0;
                const bar = document.getElementById('load-bar');
                const iv = setInterval(() => {
                    p += 4; bar.style.width = p+"%";
                    if(p>=100) {
                        clearInterval(iv);
                        setTimeout(() => {
                            const loader = document.getElementById('loader');
                            if(loader) {
                                loader.style.opacity = 0;
                                setTimeout(() => loader.remove(), 500);
                            }
                            this.enterAttractMode();
                        }, 500);
                    }
                }, 30);
            }

            enterAttractMode() {
                this.state = 'ATTRACT';
                document.getElementById('main-menu').classList.remove('hidden');
                document.getElementById('main-menu').classList.remove('menu-hidden');
                document.getElementById('ui-layer').classList.add('hud-hidden');
                document.getElementById('menu-over').classList.add('hidden');
                document.getElementById('pause-menu').classList.add('hidden');
                this.vfx.uni.blur.value = 0.8;
                this.handleResize();
                this.startRound();
            }
            
            goToMenu() {
                this.enterAttractMode();
            }

            transitionToGame(mode) {
                if(this.state === 'PLAYING') return;
                
                this.mode = mode;
                
                // UI Update
                const scoreLim = document.getElementById('score-limit');
                scoreLim.innerText = mode === 'SURVIVAL' ? "SURVIE" : "5 PTS VICTOIRE";

                document.getElementById('main-menu').classList.add('menu-hidden');
                document.getElementById('menu-over').classList.add('hidden');
                document.getElementById('pause-menu').classList.add('hidden');
                
                // Reset State
                this.score = {p1:0, p2:0};
                this.updateScoreUI();
                this.balls.forEach(b => b.active = false);
                this.powerups.forEach(p => p.kill(this.scene));
                this.p1.pos.y = 0; this.p2.pos.y = 0;
                this.p1.shieldActive = false; this.p2.shieldActive = false;
                
                // Camera Animation Trigger
                this.handleResize(); 

                setTimeout(() => {
                    this.state = 'PLAYING';
                    this.vfx.uni.blur.value = 0;
                    document.getElementById('ui-layer').classList.remove('hud-hidden');
                    this.startRound();
                    this.clock.getDelta(); // Reset clock
                }, 600);
            }

            startRound() {
                this.balls.forEach(b => { b.active=false; b.mesh.visible=false; b.trail.visible=false; });
                const dir = Math.random()>0.5 ? 1 : -1;
                this.balls[0].spawn(0, 0, dir*CFG.PHYSICS.BASE_SPEED, (Math.random()-0.5)*10);
            }

            spawnPU() {
                if(this.powerups.length < 2) {
                    const t = ['SHIELD', 'MULTI', 'THUNDER'][Math.floor(Math.random()*3)];
                    this.powerups.push(new PowerUp(this.scene, t));
                }
            }

            update(dt, t) {
                // If paused, skip game logic but keep camera/rendering active
                if (this.state === 'PAUSED') return;

                // Smooth Camera Transition (Responsive)
                this.camera.position.z += (this.targetCamZ - this.camera.position.z) * dt * 3;

                if(this.state === 'ATTRACT') {
                    // Idle animation
                    this.camera.lookAt(0,0,0);
                    this.camera.position.x = Math.sin(t*0.2)*5;
                } else {
                    this.camera.position.x = 0;
                    this.camera.lookAt(0,0,0);
                }

                if(Math.random() < 0.002 && this.state === 'PLAYING') this.spawnPU();

                // INPUT MAPPING
                // Map the normalized input (-1..1) to the actual field coordinates
                const inputY = this.input.getNormalizedY() * (CFG.FIELD.H/2);
                
                // PADDLES AI & PLAYER
                let p1T = 0, p2T = 0;
                
                const getBallY = (xSide) => {
                    let b = this.balls.find(ball => ball.active && Math.sign(ball.vel.x) === Math.sign(xSide));
                    if(!b) b = this.balls.find(ball => ball.active); 
                    return b ? b.pos.y : 0;
                };

                if(this.state === 'ATTRACT') {
                    p1T = getBallY(-1) + Math.sin(t*3)*2; 
                    p2T = getBallY(1) + Math.cos(t*2)*2;
                } else if (this.state === 'PLAYING') {
                    p1T = inputY; // Player Control
                    // AI Difficulty
                    const error = this.mode === 'SURVIVAL' ? Math.sin(t*10)*1.5 : Math.sin(t*5)*3;
                    p2T = getBallY(1) + error; 
                }

                this.p1.update(p1T, dt);
                this.p2.update(p2T, dt);

                // PHYSICS LOOP
                this.balls.forEach(b => {
                    if(!b.active) return;
                    b.update(dt);
                    
                    // Walls
                    if(Math.abs(b.pos.y) > CFG.FIELD.H/2) {
                        b.vel.y *= -1; b.pos.y = Math.sign(b.pos.y)*CFG.FIELD.H/2;
                        if(this.state === 'PLAYING') {
                            this.audio.playImpact(0.5, 'wall');
                            this.vfx.shake = 0.5;
                        }
                    }
                    
                    // Collision Logic
                    const checkPaddle = (p, id) => {
                        // AABB Collision (Simple Box)
                        const dx = Math.abs(b.pos.x - p.pos.x);
                        const dy = Math.abs(b.pos.y - p.pos.y);
                        
                        // Hit Paddle
                        if(dx < 1.5 && dy < p.h/2 + 0.6) {
                            b.vel.x *= -1;
                            b.vel.multiplyScalar(1.05); b.vel.clampLength(0, CFG.PHYSICS.MAX_SPEED);
                            b.vel.y += (b.pos.y - p.pos.y) * 2; // Add Spin
                            b.pos.x = p.pos.x + (id===1?1.5:-1.5); // Push out
                            
                            if(this.state === 'PLAYING') {
                                this.audio.playImpact(b.vel.length()/100, 'paddle');
                                this.vfx.emit(b.pos.x, b.pos.y, p.color, 20);
                                this.vfx.shake = 1.0;
                            }
                            return true;
                        }
                        return false;
                    };
                    
                    if(b.vel.x < 0) checkPaddle(this.p1, 1); else checkPaddle(this.p2, 2);

                    // Shield Logic (Separate check for wider hitbox)
                    [this.p1, this.p2].forEach((p, i) => {
                        if(p.shieldActive) {
                            const dx = Math.abs(b.pos.x - p.pos.x);
                            const dy = Math.abs(b.pos.y - p.pos.y);
                            if(dx < 3 && dy < 5) {
                                // Only bounce if moving TOWARDS shield
                                const movingTowards = (i===0 && b.vel.x < 0) || (i===1 && b.vel.x > 0);
                                if(movingTowards) {
                                    b.vel.x *= -1; p.shieldActive = false;
                                    this.vfx.emit(b.pos.x, b.pos.y, CFG.COLORS.SHIELD, 50);
                                }
                            }
                        }
                    });

                    // Powerups Interaction
                    this.powerups.forEach(p => {
                        if(p.active && b.pos.distanceTo(p.pos) < 1.5) {
                            p.kill(this.scene);
                            if(this.state === 'PLAYING') {
                                this.audio.playImpact(1, 'wall');
                                this.vfx.uni.aberration.value = 0.02;
                                setTimeout(() => this.vfx.uni.aberration.value = 0.005, 200);
                                
                                if(p.type === 'SHIELD') (b.vel.x > 0 ? this.p1 : this.p2).shieldActive = true;
                                if(p.type === 'MULTI') {
                                    const b2 = this.balls.find(x => !x.active);
                                    if(b2) b2.spawn(b.pos.x, b.pos.y, b.vel.x, b.vel.y * -1);
                                }
                                if(p.type === 'THUNDER') b.vel.multiplyScalar(1.5);
                            }
                        }
                    });

                    // Scoring
                    if(Math.abs(b.pos.x) > CFG.FIELD.W/2 + 3) {
                        b.active = false; b.mesh.visible = false; b.trail.visible = false;
                        if(this.state === 'PLAYING') this.handleScore(b.pos.x > 0 ? 'p1' : 'p2');
                        else this.startRound();
                    }
                });

                this.powerups.forEach(p => p.update(t));
            }

            handleScore(winner) {
                // Survival Mode Logic
                if(this.mode === 'SURVIVAL') {
                    if(winner === 'p2') { this.endGame('p2'); return; }
                    this.score.p1++;
                    this.updateScoreUI();
                    this.vfx.shake = 1.5;
                    setTimeout(() => this.startRound(), 500);
                    return;
                }
                
                // Standard Logic
                this.score[winner]++;
                this.updateScoreUI();
                this.vfx.shake = 2.0;
                
                if(this.score[winner] >= CFG.GAME.WIN_SCORE) this.endGame(winner);
                else setTimeout(() => this.startRound(), 1000);
            }

            updateScoreUI() {
                if(this.mode === 'SURVIVAL') {
                    document.getElementById('p1-score').innerText = this.score.p1;
                    document.getElementById('p2-score').innerText = "∞"; 
                } else {
                    document.getElementById('p1-score').innerText = this.score.p1;
                    document.getElementById('p2-score').innerText = this.score.p2;
                }
                
                const max = Math.max(this.score.p1, this.score.p2);
                if(this.mode === 'STANDARD' && max >= CFG.GAME.MATCH_POINT) {
                    document.getElementById('sb-container').classList.add('match-point');
                }
            }

            endGame(winner) {
                this.state = 'OVER';
                setTimeout(() => {
                    document.getElementById('menu-over').classList.remove('hidden');
                    const txt = document.getElementById('win-title');
                    const scoreTxt = document.getElementById('final-score');
                    
                    if(this.mode === 'SURVIVAL') {
                        txt.innerText = "ÉLIMINÉ";
                        txt.style.color = "#ff0055";
                        scoreTxt.innerText = this.score.p1 + " ROUNDS";
                    } else {
                        txt.innerText = winner === 'p1' ? "VICTOIRE" : "DÉFAITE";
                        txt.style.color = winner === 'p1' ? "#00f3ff" : "#ff0055";
                        scoreTxt.innerText = this.score.p1 + " - " + this.score.p2;
                    }
                    document.getElementById('ui-layer').classList.add('hud-hidden');
                }, 1000);
            }

            animate() {
                requestAnimationFrame(this.animate);
                // Delta limit (0.1) prevents physics explosion if tab was inactive
                const dt = Math.min(this.clock.getDelta(), 0.1); 
                const time = this.clock.elapsedTime;
                
                this.update(dt, time);
                
                // Visuals (particles, bloom) continue running even if game is paused for aesthetic reasons
                this.vfx.update(dt);
                this.vfx.cmp.render();
            }
        }

        // Start Game
        window.addEventListener('DOMContentLoaded', () => {
             window.game = new Game();
        });
    </script>
</body>
</html>
